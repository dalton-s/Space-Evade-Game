<!doctype html>
<html>
  <head>
    <meta charset='UTF-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0'>
    <meta http-equiv='X-UA-Compatible' content='ie=edge'>
    <title>Space Evade</title>
    <script src='https://pixijs.download/release/pixi.min.js'></script>
    <script src='asteroid.js'></script>
  </head>
  <body>

    <script>
      let app = new PIXI.Application({ width: 800, height: 600, backgroundColor: 0xAAAAAA });
      document.body.appendChild(app.view);

      console.log('Implement ES6 Arrow Functions!');

      // Loads sprites
      let spaceBackground = PIXI.Sprite.from('/img/space-background.png');
      spaceBackground.interactive = true;
      app.stage.addChild(spaceBackground);

      let playerShip = PIXI.Sprite.from('/img/player-ship.png');
      let playerShipXVelocity = 0;
      let playerShipYVelocity = 0;
      playerShip.anchor.set(0.5);
      app.stage.addChild(playerShip);

      let canTeleport = true;
      let previousAsteroidCreationTime = 0;

      let health = 100;
      let healthText = new PIXI.Text('Health: ' + health);
      healthText.x = 20;
      healthText.y = 60;
      healthText.style.fill = 0xFAAF30;
      app.stage.addChild(healthText);

      let score = 0;
      let scoreText = new PIXI.Text('Score: ' + score);
      scoreText.x = 20;
      scoreText.y = 20;
      scoreText.style.fill = 0xFFFF30;
      app.stage.addChild(scoreText);


      let asteroidArray = [];
      const asteroidContainer = new PIXI.Container();
      app.stage.addChild(asteroidContainer);
      const asteroidTexture = PIXI.Texture.from('/img/asteroid-01.png');

      let blackHole = PIXI.Sprite.from('/img/black-hole.png');
      blackHole.anchor.set(0.5);
      blackHole.x = 300;
      blackHole.y = 300;
      app.stage.addChild(blackHole);
      
      

      // Init mouseCursor for tracking last player cursor movement
      let mouseCursor = { x:0, y:0 }

      console.log('Add cool transform effects with math on ship?');

      // Mouse interactions
      app.stage.interactive = true;
      app.stage.on('pointermove', updateCursorPosition);

      spaceBackground.on('mouseup', function (event) {
        if(canTeleport) {
          let pos = event.data.global;
          playerShip.x = pos.x;
          playerShip.y = pos.y;
        }
      });

      function updateCursorPosition(event) {
        if(event.pressure < 0.1) {
          let pos = event.data.global;
          mouseCursor.x = pos.x;
          mouseCursor.y = pos.y;
        }
      }

      function getDistance(object1, object2) {
        var a = object1.x - object2.x;
        var b = object1.y - object2.y;
        return Math.sqrt( a*a + b*b );
      }

      function handleAsteroidSpawning() {
        // console.log('prev time: ' + previousAsteroidCreationTime + ' - elapsed: ' + elapsed);
        if(previousAsteroidCreationTime < elapsed - (40 - (score/100000000)) + 10 ) {
          console.log('spawning asteroid');
          previousAsteroidCreationTime = elapsed;
          // Create an asteroid
          let newAsteroid =  new PIXI.Sprite(asteroidTexture);
          newAsteroid.anchor.set(0.5);
          newAsteroid.x = Math.random() * 800;
          newAsteroid.y = 0 - newAsteroid.height / 2;
          newAsteroid.testVelocity = (Math.random() * 2) + 1;
          app.stage.addChild(newAsteroid);
          asteroidArray.push(newAsteroid);

        }
      }

      function playerIsDamaged(damage) {
        health -= damage;
      }

    

      // Add a ticker callback to move the sprite back and forth
      let elapsed = 0.0;
      app.ticker.add((delta) => {
        elapsed += delta;
        scoreText.text = 'Score: ' + score;
        healthText.text = 'Health: ' + Math.round(health);
        // score = Math.floor((elapsed/10) * (elapsed * 1.00000001));
        score = Math.floor(elapsed / 3);

        playerShipXVelocity = (playerShip.x - mouseCursor.x) / 20;
        playerShipYVelocity = (playerShip.y - mouseCursor.y) / 20;
        playerShip.x -= playerShipXVelocity * delta;
        playerShip.y -= playerShipYVelocity * delta;
        handleAsteroidSpawning();
        asteroidContainer.rotation = 0.21 * delta;
        let distance = getDistance(blackHole, playerShip);
        if(distance < 250) {
          blackHole.rotation -= (0.04 + ((distance+100) / 1000) ) * delta;
        } else {
          blackHole.rotation -= 0.15 * delta;
        }
        //blackHole.rotation = ( getDistance(blackHole, playerShip) / 100 ) * delta;
        asteroidArray.forEach(asteroid => {
          if(asteroid.y > 444) { 
             asteroidContainer.removeChild(asteroid);
             app.stage.removeChild(asteroid);
            // asteroidArray.pop(asteroidArray.indexOf(asteroid));
            // let asteroidIndex = asteroidArray.indexOf(asteroid);
            // console.log(asteroidIndex);
            // if(asteroidIndex == 0) { asteroidArray.pop() }
            // else { 
            //   let arrayPart1 = asteroidArray.slice(0, asteroidIndex - 1);
            //   let arrayPart2 = asteroidArray.slice(asteroidIndex + 1);
            //   let newAsteroidArray = array1.concat(array2);
              //asteroidArray = newAsteroidArray;
            // }

            // asteroid.destroy();
           } else {
            asteroid.rotation -= (0.001 * (asteroid.testVelocity * 15)) * delta;
            asteroid.y += asteroid.testVelocity;
            // Checks for player collision
            if (playerShip.x < asteroid.getBounds().x + asteroid.getBounds().width &&
            playerShip.x + playerShip.width / 2 > asteroid.getBounds().x &&
            playerShip.y < asteroid.getBounds().y + asteroid.getBounds().height &&
            playerShip.y + playerShip.height > asteroid.getBounds().y) {
              playerIsDamaged(0.5);
            } 
            // var graphics = new PIXI.Graphics();
            // graphics.beginFill(0xFFFF00);
            // // set the line style to have a width of 5 and set the color to red
            // graphics.lineStyle(5, 0xFF0000);
            // // draw a rectangle
            // graphics.drawRect(50, 300, health, 40);
            // app.stage.addChild(graphics);

          }
        });

        if (playerShip.x < blackHole.getBounds().x + blackHole.getBounds().width &&
            playerShip.x + playerShip.width / 2 > blackHole.getBounds().x &&
            playerShip.y < blackHole.getBounds().y + blackHole.getBounds().height &&
            playerShip.y + playerShip.height > blackHole.getBounds().y) {
              playerIsDamaged(2);
            }
      });

      

    

    </script>
  </body>
</html>